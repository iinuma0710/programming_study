# 第7章 継承
ここでは，クラスの重要な機能である継承について詳しく見ていく．

## 7.1 アクセス制御
### 7.1.1 基底クラスのアクセス制御
```public``` アクセス修飾子で派生した場合，

- 基底クラスの公開メンバは，そのまま派生クラスの公開メンバに
- 基底クラスの非公開メンバは，派生クラスからもアクセスできない非公開メンバに

になる．
一方，```private``` アクセス修飾子を使用して派生すると，基底クラスの全てのメンバが派生クラスの非公開メンバとなる．
非推奨ではあるが，この機能を「別物だが機能的に近いクラスを作る」時などに，既存のプログラムを再利用するのに使うことができる．

```cpp
#include <iostream>

class Base
{
    void private_member()
    {
        std::cout << "Base::private_member()" << std::endl;
    }

public:

    void public_member()
    {
        std::cout << "Base::public_member()" << std::endl;
    }
};

class Derived : private Base    // private で派生
{
public:
    void member_test();
};

void Derived::member_test()
{
    // エラー．基底クラスの非公開メンバにはアクセスできない
    private_member();
    // OK．基底クラスの公開メンバにはアクセスできる
    public_member();
}

int main()
{
    Base base;
    Derived derived;
    
    base.private_member();  // エラー．
    base.public_member();   // OK．
    derived.private_member();   // エラー．
    derived.public_member();    // エラー．
}
```

### 7.1.2 被保護メンバ (protected members) の使用
派生クラスは多くの場合，基底クラスを拡張したクラスとなり，基底クラスの持つメンバ変数や関数にアクセスできた方が柔軟な拡張が可能となる．
しかし，何でもかんでも公開してしまうと，カプセル化を維持するのが困難になる．

そこで，被保護メンバを用いることによって，クラス外からはアクセスできない一方，派生クラスからはアクセスできるメンバを定義できる．
しかし，本来であれば基底クラス外である派生クラスから，基底クラス内のメンバにアクセスするのは避けるべきであり，やむを得ない事情がない限り使用は避けるべきである．

## 7.2 継承時のコンストラクタ/デストラクタの動作
ここでは，コンストラクタやデストラクタが継承の際にどのように動作するかを見ていく．

### 7.2.1 呼び出しの順序
コンストラクタは基本的に最も基底にあるクラスのコンストラクタから順番に処理されていく．
派生したクラスのコンストラクタが呼ばれる時には，基底クラスの処理は終わっているので，派生クラスのコンストラクタでは基底クラスに依存した処理を記述できる．  
一方，デストラクタはコンストラクタとは逆に，派生クラスの方から順に処理されていく．
そのため，RAII を正しく実現できるようになっている．

### 7.2.2 コンストラクタの引数
メンバ初期化リストを使って，派生クラスのコンストラクタだけでなく，基底クラスのコンストラクタに引数を渡すこともできる．

```cpp
// コンストラクタの定義
class-name::class-name(parameters・・・)
    : base-class-name{arguments・・・}
    , member{initial-value}, member{initial-value}, ・・・
{
    // コンストラクタの本体
}
```

基底クラスのコンストラクタ呼び出しは必須ではなく，省略した場合にはデフォルトコンストラクタが呼ばれる．
また，基底クラスのコンストラクタは一番初めに呼び出されるので，他のコンストラクタよりも先に書いておくと可読性が上がる．

## 7.3 派生クラスへのポインタ
クラスはそのクラス自体を指す ```this``` ポインタを持ち，派生クラスでも同様に使うことができる．
派生クラスには基底クラスがあり，基底クラスのメンバだけあれば問題ないような場合や，基底クラスへのポインタや参照を引数として受け取るような関数がある場合に，派生クラスを渡すことができると便利である．  
逆に，基底クラスは派生クラスのメンバを全て持っているわけではないので，基底クラスのインスタンスを派生クラスへのポインタや参照に代入できない．

## 7.4 仮想関数の詳細
### 7.4.1 仮想関数 (再び)
仮想関数は，基底クラスの動作そのものを派生クラスから変更する機能であり，
関数が基底クラスのポインタや参照しか受け取らないような場合に動作を変えるのに使われる．
基底クラスしか受け取らないような関数であっても，基底クラスに見せかけつつ，派生クラスでオーバライドしたメンバ関数の呼び出しを行わせるといったことができる．

### 7.4.2 型指定して基底クラスのメンバ関数を呼び出す
基底クラスのメンバ関数を派生クラスで定義したオーバライド関数から呼び出すことで，基底クラスに機能を追加することができる．
しかし，この呼び出し方法を間違えると止まらないプログラムになってしまう．
(list_7_6.cpp)  
仮想関数は基底クラスのポインタや参照から派生クラスのメンバ関数を呼ぶ機能であり，
```Base::method()``` メンバ関数を呼び出しているつもりでも，再帰呼び出し (recusive call) となり，繰り返し自分自身 (```Derived::method()```) を呼び出してしまう．
正しく基底クラスのメンバ関数を呼び出すには次のようにする．

```cpp
void Derived::method()
{
    std::cout << "Derived::method()" << std::endl;
    Base::method();  // または this->Base::method(); としても良い
}
```

### 7.4.3 非公開メンバの仮想関数
基底クラスの非公開メンバは，呼び出すことはできないものの，オーバライドは可能である．
オーバライドはできても，基底クラスの非公開メンバのデフォルト動作などを引き継ぐことはできない．
そのため，仮想関数は本当に動作に違いを出したい一部にのみ使い，共通部分は通常の公開メンバ関数として基底クラスに実装することが望ましい．

### 7.4.4 仮想デストラクタ (virtual destructor)
デストラクタを仮想関数にしたものを仮想デストラクタと呼び，そのようなクラスをポリモーフィック (polymorphic) なクラスと呼ぶ．
ポリもーフィックなクラスはオブジェクト指向においてポリモーフィズム (多態性：polymorphism) を実現する一つの方法である．  
仮想デストラクタは，動的確保した継承を使ったオブジェクトを解放するときに，正しいデストラクタが呼ばれるようにするための機能であり，list_7_8.cpp の場合には仮想デストラクタを使わないとデストラクタ呼び出しが不完全になってしまう．  
list_7_8.cpp はコンパイルは通るものの，```allocate()``` 関数からは基底クラスへのポインタが返され，```delete``` 演算子で基底クラスのデストラクタを呼び出しており，```new``` で新規作成した派生クラスのインスタンスが解放されず，メモリリークが起きてしまう．
そこで，仮想デストラクタを使い，オブジェクトを実体化した時の派生クラスのデストラクタでオーバライドすることで，基底クラスへのポインタしか持っていなくても，正しく派生クラスのデストラクタの呼び出しができるようになる．

```cpp
class Base
{
public:
    virtual ~Base()
    {
        std::cout << "Base::~Base()" << std::endl;
    }
};
```

基本的に基底クラスのデストラクタさえ仮想デストラクタになっていれば，派生クラスでからのデストラクタを定義する必要はない．
ただし，仮想デストラクタはパフォーマンスに大きな影響を与える可能性があり，使用する場面は慎重に選ぶ必要がある．

## 7.5 多重継承 (multiple inheritance)
複数の基底クラスを継承することを多重継承と呼ぶ．
多重継承したクラスは，継承した全ての基底クラスの機能を兼ね備え，メンバ関数を使うことができる．
また，全ての基底クラスへのポインタや参照へも代入できる．

### 7.5.1 多重継承の注意点
多重継承はクラスの継承関係を複雑にしかねないため，オブジェクト指向をサポートする他のプログラミング言語では禁止されていることもある．
そのため，多重継承を使う場面は慎重に見極める必要がある．
C++以外の言語では，多重継承の代わりにインタフェイス (interface) と呼ばれる機能で代用されることが多い．

### 7.5.2 多重継承時の基底クラスのコンストラクタ呼び出し
多重継承時に基底クラスのコンストラクタを呼び出す時には，継承している基底クラスの数だけコンストラクタ呼び出しを列挙するだけで良い．
ただし，基底コンストラクタの呼び出しは継承している順番に処理されることになっているため，
継承の順番と初期化リストの順番は一致させておくことが望ましい．

### 7.5.3 曖昧な呼び出しと基底クラス名の指定
多重継承の問題点として，どの基底クラスから派生したのか曖昧になるという問題がある．
list_7_12.cpp のように，どの継承先を際sているのか曖昧な箇所があると，コンパイルの時点でエラーになる．
そのため，list_7_13.cpp のように曖昧さを残さないように記述する必要がある．

## 7.6 仮想基底クラス (virtual base class)
前述のように，継承関係によっては基底クラスが曖昧になってしまう問題が生じるが，
明示的に基底クラスを指定する以外にも，これを解決する方法として仮想基底クラスが提供されている．

### 7.6.1 菱形継承
仮想基底クラスを使わない場合，重複する基底クラスは複数存在していたが，
仮想基底クラスを使用すると，基底クラスがただ1つだけ存在するようにクラスが作成される．
これによって，基底クラスのメンバ関数呼び出しの曖昧さが解消される．
このような継承関係のことを，菱形継承，またはダイヤモンド継承と呼ばれる．

### 7.6.2 仮想基底クラスのコンストラクタ呼び出し
仮想基底クラスのコンストラクタは，インスタンスを生成する時のクラスのコンストラクタで呼び出すことになっている．
そのため，何段階にもわたって継承関係がある場合には，それぞれのクラスで適切な引数で初期化する必要がある．

## 7.7 派生，オーバライドの抑止
クラスは基本的に，他のクラスを制限なく基底クラスにして派生することができるが，
派生クラスでの変更によっては，意図しない動作を引き起こす恐れがある．
そこで，派生やオーバライドを抑止する機能が提供されている．

### 7.7.1 クラスの final 指定
```final``` を指定しておくと，それ以上派生クラスを作成できなくなる．

```cpp
class Base {};

// final 指定
class FinalClass final : public Base {};

// final 指定したクラスを継承しようとしているためエラーとなる
class MoreDerived : public FinalClass {};
```

### 7.7.2 仮想関数の final 指定
クラス全体だけでなく，仮想関数のオーバライドを個別に抑制することもできる．
```override``` 指定の代わりに ```final``` 指定を使うことで，その仮想関数のオーバライドを禁止できる．

```cpp
class Base
{
public:
    virtual void method1()
    {
        std::cout << "Base::method1()" << std::endl;
    }

    virtual void method2()
    {
        std::cout << "Base::method2()" << std::endl;
    }
};

class Derived : public Base
{
public:
    // final 指定
    void method1() final
    {
        std::cout << "Derived::method1()" << std::endl;
    }

    void method2() override
    {
        std::cout << "Derived::method2()" << std::endl;
    }
};

class MoreDerived : public Derived
{
public:
    // Derived で method1 は final 指定されているのでエラーとなる
    void method1() override
    {
        std::cout << "MoreDerived::method1()" << std::endl;
    }

    void method2() override
    {
        std::cout << "MoreDerived::method2()" << std::endl;
    }
};
```