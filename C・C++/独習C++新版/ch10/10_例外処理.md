# 第10章 例外処理

## 10.1 例外処理の基礎
例外処理 (exception handling) は C++ のエラー処理機構である．
例外処理では，エラーが起きた箇所で，そのエラーに関する情報を持った例外オブジェクト (exception object) を投げる (throw) と，
その例外を捕まえる (catch) まで呼び出し元を遡る．

### 10.1.1 throw / try / catch
例外処理には ```throw``` 文と ```try``` 節，(必要に応じて) ```catch``` 節からなる．

まず，```try``` ブロック内から ```throw``` 文で例外が投げられると，続く ```catch``` 節に処理が移る．
```try``` ブロック内で例外が投げられなければ，```catch``` 節の処理は実行されない．
```catch``` 節には受け取る例外オブジェクトの型を記述でき，投げられた例外オブジェクト(またはその派生クラスのオブジェクト)の型と一致する
```catch``` 節の処理が実行される．
```throw``` 文はどこにでも記述できるが，```catch``` 節は ```try``` と合わせて使う必要がある．
また，```throw``` で投げる例外オブジェクトに制限はないが，
通常 ```std::exception``` クラスから派生したクラスを目的に応じて作成し，それを投げる．

```cpp
// try ブロックと catch 節
try
{
    statement...
}
catch (type variable)
{
    statement...
}

// 例外を投げる
throw exception-object;
```

### 10.1.2 複数の catch 節
```catch``` 節は1つの ```try``` ブロックに対して複数記述することができる．
複数の ```catch``` 節がある場合には，上から順番に投げられた例外を最初に捕まえられたものだけが処理される．
もし，最後の ```catch``` 節まで行っても例外を捕まえられなかった場合には，```std::terminate()``` 関数が呼ばれ，
プログラムを強制終了する．

```cpp
// try ブロックと catch 節
try
{
    statement...
}
catch (type0 variable0)
{
    statement...
}
catch (type1 variable1)
{
    statement...
}
...
catch (typeN variableN)
{
    statement...
}
```


## 10.2 例外処理の詳細
### 10.2.1 すべてを捕まえる catch 節
どのような例外が投げられるかわからないと，そのままではプログラムが強制終了させられてしまうが，
サーバプログラムのようにプログラムの実行が停止しては困るような場合もある．
そこで，例外オブジェクトの型に関係なくエラーを捕捉する ```catch``` 節を記述できる．
この ```catch``` 節は最後に1つだけ記述できることになっている．

```cpp
catch(...)
{
    // 全ての例外を捕捉する
    statement......
}
```

### 10.2.2 例外の再送出
例外が投げられ ```catch``` 節に処理が移ると，途中で確保していたリソースなどの解放ができなくなり，
メモリリークの原因となる場合がある．

```cpp
void throw_zero()
{
    char* buffer = new char[10];    // 何かのバッファ

    ...

    throw 0;

    delete [] buffer;   // 呼ばれない
}
```

このような場合，一度エラーを捕捉してリソースを解放してからもう一度エラーを投げることでメモリリークなどを防ぐことができる．

```cpp
void throw_zero()
{
    char* buffer = new char[10];    // 何かのバッファ

    try
    {
        ...

        throw 0;
    }
    catch (int e)
    {
        delete [] buffer;
        throw e;
    }

    delete [] buffer;
}
```

しかし，このやり方には

- ```catch(...)``` の場合にはもう一度投げるべき例外オブジェクトがわからない
- 2つ目に投げられる例外オブジェクトは，1つ目のコピーとなる

という問題がある．
1つ目は特に大きな問題であるが，例外オブジェクトを指定しない throw 文でもう1度例外を投げることができる．
このように，一度捕捉した例外を再び投げることを再送出 (rethrow) と呼ぶ．

### 10.2.3 noexpect 指定
例外はどこからでも投げられるため，どの関数から飛んで来るかは分からない．
しかし，```noexcept``` 指定をすることで，「その関数からは絶対に例外が投げられない」という宣言ができる．

```cpp
return-type function-name(parameters......) noexcept;

return-type function-name(parameters......) noexcept
{
    function-body......
}
```

もし，```noexcept``` 指定された関数内で例外が発生しても，その時点で ```std::terminate()``` が呼ばれ強制終了となる．
ただし，例外を関数ないで処理するのであれば，```noexcept``` 指定された関数内で例外が発生しても ```std::terminate()``` は呼ばれない．

## 10.3 new 演算子の例外処理
### 10.3.1 std::bad_alloc 例外
```new``` 演算子で動的に必要なメモリを確保できなかった場合には，```std::bad_alloc``` 例外が投げられる．
```new``` 演算子での動的割り当てに失敗するような場合，ほとんどは強制終了させるしかなく，ログに出力する程度のことしかできない．  
ちなみに，```catch``` 節で参照を使って例外オブジェクトを渡しているのは，例外オブジェクトのコピーと，それに伴うメモリの動的な確保を防ぐためである．
もし，例外オブジェクトのコピー中にさらに例外が発生すると，ダブルフォルト (double fault) となって強制終了される．

### 10.3.2 std::bad_array_new_length 例外
初期化リストの長さより確保した動的配列が短い場合，```std::bad_array_new_length``` 例外が投げられる．
初期化リストの方が短い場合には例外は送出されず，初期化リストにない領域は0で初期化される．

### 10.3.3 コンストラクタから投げられる例外
```new``` 演算子で構築しようとしているクラスのコンストラクタから例外が送出される場合がある．
この時，コンストラクタが呼ばれていることから，必要なメモリ領域は確保できているはずで，
確保されたメモリ空間を解放した上で例外が送出されるため，メモリリークなどの恐れはなく，
例外処理で特別な操作は必要ない．

配列を初期化している途中のコンストラクタで例外が投げられた場合，それまでに初期化が完了した全てのインスタンスのデストラクタが呼ばれる．
同様に，```new``` 演算子による配列の動的確保の場合にも，それまでに初期化が完了したインスタンスのデストラクタが呼ばれる．
また，動的確保済みのメモリ領域についても自動的に解放処理が行われる．


## 10.4 標準例外
### 10.4.1 std::exception と what() メンバ関数
標準ライブラリが投げる例外は全て ```<exception>``` ヘッダで定義された ```std::exception``` 例外から派生しており，```what()``` メンバ関数を持つ．
自分で例外クラスを作成する場合には，この ```what()``` 関数をオーバライドして，適切なメッセージを返すようにする．

```cpp
virtual const char* what() const noexcept;
```

### 10.4.2 標準ライブラリで定義されている例外クラス
標準ライブラリでは ```std::exception``` を基底クラスとして，次のような例外クラスが用意されている．

| 例外 | 目的 | 基底クラス | ヘッダ |
| :-- | :-- | :-- | :-- |
| std::bad_alloc | new 演算子でのメモリ確保失敗を通知 | std::exception | \<new> |
| std::bad_array_new_length | 配列の new 演算子に渡された初期化リスト長の不一致を通知 | std::exception | \<new> |
| std::logic_error | プログラムロジックのエラー | std::exception | \<stdexcept> |
| std::out_of_range | 標準ライブラリのコンテナなどでの範囲外アクセスを通知 | std::logic_error | \<stdexcept> |
| std::runtime_error | 実行時に起きたオーバフローなどの各種エラーを通知 | std::exception | \<stdexcept> |
| std::invalid_argument | 関数の引数が期待していないものであったことを通知 | std::logic_error | \<stdexcept> |