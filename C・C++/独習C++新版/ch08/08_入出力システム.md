# 第8章 入出力システム
ここでは，プログラムと人とのインタラクションには欠かせない，入出力システムについて述べる．

## 8.1 C++ の入出力の基礎
C++ の入出力は C 言語と同じくストリーム (stream) を通じて行われる．
ストリームに接続しているキーボードや画面，ファイルなどを統一的なインタフェイスを通じて扱うことができる．
ストリームには次の4つのストリームがある．

| ストリーム | デフォルトで接続されるデバイス | 入出力オブジェクト | C 言語でのストリーム |
| :-- | :-- | :-- | :-- |
| 標準入力 | キーボード (コンソール入力) | std::cin | stdin |
| 標準出力 | 画面(コンソール出力) | std::cout | stdout |
| 標準エラー出力 | 画面(コンソール出力) | std::cerr | stderr |
| バッファ付き標準エラー出力 | 画面(コンソール出力) | std::vlog | - |

このうち，バッファ付き標準エラー出力は特殊な用途でしか使うことはないので，これ以外の3つを覚えておけば良い．

これら入出力オブジェクトは，```iostream``` ヘッダで定義されたテンプレート (第9章参照) の実体である．
```std::cin``` は入力を専門に行う ```std::basic_istream``` テンプレートクラスをもとに作られ，他の3つのストリームは出力を専門に行う ```std::basic_ostream``` テンプレートクラスをもとに作られている．
他にも，```std::basic_iostream``` テンプレートクラスやファイルを扱うためのテンプレートクラスなどがある．
ここでは，```std::istream``` や ```std::ostream```，```std::iostream``` を使用して，高水準入出力を用いた数値フォーマットや空白の処理などを行う．
これ以外にも低水準入出力をサポートする ```std::basic_streambuf``` が直接デバイスとやりとりしている．

## 8.2 書式設定された出力
これまで，標準ライブラリがデフォルトで提供しているフォーマットで，さまざまな値を出力していた．
しかし，標準ライブラリでは浮動小数点を指数表示に変換するといった書式の変換を行う機能が提供されている．

### 8.2.1 std::ios::fmtflgs フラグ
表示する書式を変換するだけならば，次のようなフラグを設定することで簡単に切り替えることができる．

| std::ios::fmtflags | 効果 |
| :-- | :-- |
| std::ios::boolalpha | bool 方を出力するとき true / false で出力する |
| std::ios::dec | 数値を10進数で出力する |
| std::ios::fixed | 浮動小数点数を固定表記で出力する |
| std::ios::hex | 数値を16進数で出力する |
| std::ios::internal | 中央揃え (何桁の中央に揃えるかは別途指定) |
| std::ios::left | 左詰で出力する |
| std::ios::oct | 数値を8進数で出力 |
| std::ios::right | 右詰めで出力する (何桁の右詰めかは別途指定) |
| std::ios::scientific | 浮動小数点数を科学技術表記で出力する |
| std::ios::showbase | 数値を出力するときに8進数なら0を16進数なら0xを先頭に付ける |

上記のフラグは代表的なもので，これ以外にもいくつかのフラグが存在する．
ストリームオブジェクトにセットされているフラグを取得するには ```flags()``` メンバ関数を，フラグのセットには ```setf()``` メンバ関数を，セットされたフラグをアンセットするには ```unset()``` メンバ関数をそれぞれ用いる．

```cpp
std::ios::fmtflags flags() const;

std::ios::fmtflags setf(std::ios::fmtflags fmtfl);

void unset(std::ios::fmtflags fmtfl)
```

標準では8進数，10進数，16進数での表記をサポートしており，いったん現在の表記方法をアンセットしなければフラグが曖昧になってしまう．  
```flags()``` メンバ関数と ```setf()``` メンバ関数には，それぞれオーバロードが存在する．

```cpp
// 全てのフラグを与えられたフラグの組み合わせの通りに変更する
// 引数なしの flags() で取得したフラグ状態にリセットする
std::ios::fmtflags flags(std::ios::fmtflags fmtfl);

// mask で指定したフラグをクリアした上で fmtfl のビット and 演算をとった値をセットする
// フラグの排他指定や組み合わせのために用いる
std::ios::fmtflags setf(std::ios::fmtflags fmtfl, std::ios::fmtflags mask);
```

```setf()``` の ```mask``` によく使う組み合わせは標準が用意している．

| std::ios::fmtflags | 概要 |
| :-- | :-- |
| std::ios::adjustfield | left，internal，right の組み合わせ |
| std::ios::basefield | dec，hex，oct の組み合わせ |
| std::ios::floatfield | scientific，firld の組み合わせ |

### 8.2.2 さらに柔軟な書式設定
幅(桁)や精度，充填文字を設定することで，より細かな書式設定が可能となる．

```cpp
// 出力桁数を設定する
// デフォルトでは右詰めになるように指定された桁数に合わせた充填文字が出力される
std::streamsize width() const;
std::streamsize width(std::streamsize wide);

// 浮動小数点数の宥光桁数を指定する
std::streamsize precision() const;
std::streamsize precision(std::streamsize prec);

// 充填文字を設定する．デフォルトでは空白となっている
char fill() const;
char fill(char ch);
```

## 8.3 その他のテキスト入出力関数
整数や浮動小数点の変換をせず，テキストとして入力を受け取る場合や，確保済みのバッファを使用する場合には，細かな処理設定はせず次のような関数を使う．

```cpp
// buf に最大で num-1 文字コピーし，最後に null 文字を付与
std::istream& get(char* buf, std::streamsize num);
// delim で区切り文字を指定できる (デフォルトでは改行文字)
std::istream& get(char* buf, std::streamsize num, char delim);

// 区切り文字をストリームから除去した上で終了する
std::istream& getline(char* buf, std::streamsize num);
std::istream& getline(char* buf, std::streamsize num, char delim);
```

## 8.4 入出力マニピュレータ (I/O manipulator) の使用
入出力マニピュレータを用いることで，入出力の途中で簡単に設定を変更できる．
メンバ関数を用いたフラグのセットでは，出力用のフラグを入力にセットしたり，その逆の設定を行ったりといったことがあり得たが，マニピュレータではそのようなことは起きないという利点がある．

| マニピュレータ | 効果 | 補足 |
| :-- | :-- | :-- |
| std::boolalpha | 対応するフラグをセット | フラグをクリアする std::noboolalpha もある |
| std::dec / hex / oct | 対応するフラグをセット | セットしなかったフラグはアンセットされる |
| std::left / internal / right | 対応するフラグをセット | セットしなかったフラグはアンセットされる |
| std::fixed / scientific | 対応するフラグをセット | セットしなかったフラグはアンセットされる |
| std::hexfloat | 浮動小数点数を16進数表記にする | - |
| std::showbase | 対応するフラグをセットする | フラグをクリアする std::noshowbase もある |
| std::setfill(char c) | 充填文字を c にする | - |
| std::setprecision(int p) | 精度を P にする | - |
| std::setw(int w) | 幅を w にする | - |

## 8.5 ファイル入出力の基本
ファイルの入出力では，ユーザがファイルストリームオブジェクトを作成し，対象となるファイルを指定して開く操作が必要になる．
また，ファイルの入出力処理が終わったら閉じる操作も必要となる．

### 8.5.1 ファイルストリーム
ファイルストリームは ```std::basic_fstream``` テンプレートクラスを使う．
ここでは次の3つを用いる．

- ```std::ifstream in``` : 入力用
- ```std::ofstream out``` : 出力用
- ```std::fstream inout``` : 入出力用

ファイルを開くにはコンストラクタにファイル名を渡すか，デフォルトコンストラクタでオブジェクトを作成した後，```open()``` メンバ関数を使う．
また，ファイルを閉じるには，ファイルストリームオブジェクトのデストラクタを使うか，```close()``` メンバ関数を使う．

```cpp
// mode のデフォルト引数は入出力のいずれかによって異なる．
fstream(const std::string& filename, std::ios::openmode mode = default-openmode);

void open(const std::string& filename, std::ios::openmode mode = default-openmode);

void close();
```

### 8.5.2 ファイルオープンのモードフラグ
ファイルを開く際，用途や状態を表すモードを指定するために ```std::ios::openmode``` フラグを渡すことができる．
これらのフラグは，```open()``` の第2引数かコンストラクタの第2引数で渡すことができる．
また，複数のフラグを ```|``` を使って複数指定することもできる．
```std::ifstream``` や ```std::ofstream``` は，フラグが指定されていた場合にも，暗黙的に ```in``` や ```out``` のフラグが指定されるが，```std::fstream``` は暗黙的にフラグ指定されないことに留意する．

| モードフラグ | 意味 |
| :-- | :-- |
| std::ios::in | 入力可能なようにオープンする |
| std::ios::out | 出力可能なようにオープンする |
| std::ios::app | 出力がファイルの末尾に追加される |
| std::ios::ate | オープンするときにファイルの末尾にシークする |
| std::ios::trunc | すでにファイルが持っているデータを破棄してからオープンする |
| std::ios::binary | バイナリモードでオープンする |

```std::ios::app``` ではオープンした直後は先頭を指したままであるが，何か出力する直前に必ずファイルの末尾にシークしてから出力する．
一方，```std::ios::ate``` は，ファイルオープンしたその時にだけ，ファイルを末尾にシークするので，再度シークすれば好きな位置から読み書きできる．
常に末尾に追記していくようなファイルは，```std::ios::app``` で開いた方が，データを破壊せずに出力可能である．

```std::ios::trunc``` は作業用の一時ファイルなど，常に空であるべきファイルに対して使用する．
また，```std::ios::binary``` はいバイトごとの処理が必要な場合や，そもそも文字列を扱わない場合に指定する．

### 8.5.3 ファイルオープンの失敗
書き込み禁止ファイルを書き込みモードでオープンしたり，存在しないファイルを読み込みモードでオープンしたりした場合には，ファイルのオープンが失敗する．
もし，オープンに失敗していても，デフォルトではそのまま処理が続行されてしまうので，```is_open()``` 関数を用いてファイルがオープンできているか確認する．

```cpp
BOOL IS_open() const;
```

### 8.5.4 ファイルの終端 (EOF : End of File)
ファイルから入力する時には必ずファイル終端を考慮する必要があり，
```eof()``` 関数を使って調べることができる．

```cpp
bool eof() const;
```

## 8.6 書式不定のバイナリ入出力
テキストデータではなく，コンピュータで直接扱う書式不定のバイナリ形式でファイル入出力を行うことができる．

### 8.6.1 1バイトの入出力
最も低水準な入出力を行うのが ```get()``` と ```put()``` 関数である．

```cpp
// ストリームから1バイト読み込んで ch に格納し，使用したストリームを返す
std::istream& get(char& ch);

// ch の値をストリームに1バイトだけ書き込み，使用したストリームを返す
std::ostream& put(char ch);
```

入力ストリームでは次の1バイトを簡単に取得できる関数が用意されている．
これらの関数では，ファイルの終端を特別な定数として返しているため，```char``` 型ではなく ```int``` 型で値を返している．

```cpp
// 入力ストリームから1バイト入力し，入力したバイトをストリーム方取り除く
int get();

// 入力ストリームから1バイト入力し，入力したバイトを残したままにする
int peek();
```

### 8.6.2 ブロックのバイナリ入出力
1バイトごとの入出力で全てを賄うのは大変なので，一定サイズをブロックとして一気に入出力できる関数が用意されている．

```cpp
// num バイトを読み込んでバッファに書き込む
// num バイト中にEOFがあれば，そこまでのデータをバッファに書き込んで終了
std::istream& read(char* buf, std::streamsize num);

// 実際に読み込んだサイズを調べる
std::streamsize gcount() const;

// num バイトをストリームに書き込む
std::ostream& write(const char* buf, std::streamsize num);
```

## 8.7 ランダムアクセス (random access)
これまでは，ファイルの先頭から順番にデータを読み書きしていた (逐次アクセス：sequential access) が，自由に読み書きする場所を指定できるランダムアクセスという機能も提供されている．
一般的に，ランダムアクセスによって目的の位置に移動してから，逐次アクセスである程度まとまったデータの読み書きを行う．

## 8.7.1 現在の位置を変更する
次の関数を用いて入出力の位置を変更できる．

```cpp
// 入力ストリームの位置を変更
std::istream& seekg(std::ios::pos_type position);

// 出力ストリームの位置を変更
std::ostream& seekp(std::ios::pos_type position);
```

このように，入出力の位置を移動することをシーク (seek) と呼び，ファイル先頭からの絶対位置をバイト数で与える．

## 8.7.2 現在の位置を知る
現在のストリームの先頭からの位置を調べる関数も用意されている．

```cpp
// 入力ストリーム用
std::ios::pos_type tellg() const;

// 出力ストリーム用
std::ios::pos_type tellp() const;
```

位置情報の加減算では ```std::streamoff``` 型を使う必要があるが，
整数型からキャストすることができる．
次のように，基準となる位置 (origin) から相対位置 (offset) を指定してシークする方法もある．

```cpp
// 入力ストリームの位置を変更
std::istream& seekg(std::ios::off_type offset, std::ios::seekdir origin);

// 出力ストリームの位置を変更
std::ostream& seekp(std::ios::off_type offset, std::ios::seekdir origin);
```

```origin``` には次のような値を指定する．

| 定数 | 意味 |
| :-- | :-- |
| std::ios::beg | ファイル先頭 |
| std::ios::cur | 現在位置 |
| std::ios::end | ファイル終端 |

## 8.8 入出力状態のチェック
ストリームオブジェクトでは，ストリームの状態に関する情報を ```std::ios::iostate``` 型という値で保持している．

| 値 | 意味 |
| :-- | :-- |
| std::ios::goodbit | エラーが起きなかった |
| std::ios::eofbit | ファイルの終端に到達した |
| std::ios::failbit | 致命的ではないエラーが起きた |
| std::ios::badbit | (復旧できないような) 致命的なエラーが起きた |

## 8.8.1 現在の情報の取得
次の関数を使って，現在の情報を取得できる．

```cpp
// エラーがなければ std::ios::goodbit を返す
// それ以外の場合にはエラーフラグの組み合わせを返す
std::ios::iostream rdstate() const;

// 真偽値で状態を取得することもできる
bool good() const;
bool eof() const;
bool fail() const;
bool bad() const;
```

## 8.8.2 エラーフラグのクリア
エラーフラグは一度セットされると，追加されることはあっても勝手にリセットされることはない．
もし，エラー原因を除去できたとしても，そのフラグをクリアしなければ処理を進められない．

```cpp
void clear(std::ios::iostate flags = std::ios::goodbit);
```

デフォルト値の ```std::ios::goodbit``` にしておくと，全てのフラグがクリアされる．
もし特定の状態にしたければ，そのフラグの組み合わせを ```flags``` に渡せば良い．