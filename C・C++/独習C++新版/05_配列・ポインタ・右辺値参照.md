# 配列・ポインタ・右辺値参照

## 配列とポインタ
### ポインタへの暗黙変換
配列は先頭要素へのポインタとして暗黙変換される．
文字列リテラルも文字の配列なので同様に扱われるが，変更不可能な配列なので ```const``` 修飾されたポインタとなる．

```cpp
int array[] = {0, 1, 2, 3};

// 先頭要素のポインタ
&array[0]

// 配列からポインタへの暗黙変換 => 先頭要素のポインタと同じになる
int* ptr = array;
```

### 次のアドレス
配列をポインタに変換した場合，通常の配列と同様に添字演算子を用いて先頭以外の要素にアクセスできる．

```cpp
int array[] = {0, 1, 2, 3};
int* ptr = array;

// 先頭以外の要素にもアクセスできる
ptr[0]
ptr[1]
ptr[2]
ptr[3]
```

添字演算子を用いる以外にも，ポインタの加算や減算でもアクセス可能．

```cpp
int array[] = {0, 1, 2, 3};
int* ptr = array;

// 2番目の要素
ptr += 2
// 3番目の要素
ptr++
// 1番目の要素
ptr -= 2
// 0番目の要素
--ptr
```

### 配列と引数
引数として配列を渡す場合にも配列のコピーは作成できない．
関数の引数に配列を宣言した場合には，ポインタとして宣言されたものとして扱われる．
そのため，配列の長さが想定と異なる場合にもそのまま渡せてしまうので要注意．

```cpp
// 次の2つは同じ意味
void function(int array[5]);
void function(int* array);
```

### 配列の方と別名
配列はポインタに暗黙的に変換されるが，配列自体は配列の型を持っている．

```cpp
// 配列の型
type-name[array-length];

// 配列へのポインタ型
type-name(*)[array-length];

// 配列へのポインタ宣言
type-name(*pointer-nema)[array-length] = &array-name;

// 配列への参照型
type-name(&)[array-length];

// 配列への参照の宣言
type-name(&reference-name)[array-length] = array-name;
```

配列へのポインタや参照は型に配列の長さの情報を持っているので，範囲 for 文で走査することもできる．
また，```using``` 宣言で配列へのポインタや参照に別名を付けることができる．


## オブジェクトの配列
### オブジェクト配列と初期化
組み込み型と同様，クラスの配列を作ることもできる．
組み込み型の配列は，配列の長さと同じだけ初期値を与えることで配列の初期化を行う．
一方，クラスの配列を作る場合，明示的な型変換と呼ばれるコンストラクタの呼び出しを行い，
インスタンスの作成を行うことができる．

```cpp
type-name(arguments...)
type-name{arguments...}
```

この明示的な型変換で作成したコンストラクタを配列に詰め込むことで，配列の初期化できる．
初期化時に呼び出したコンストラクタの数より配列の方が長い場合，足りない分はデフォルトコンストラクタが呼び出される．

クラスを配列にする場合，不必要に大きな配列を作成するのは避ける．
これは，デストラクタの呼び出しが多くなり，処理速度が低下するのを防ぐためである．
また，配列は意図せず危険な操作ができてしまうことが多いため，できるだけコンテナクラスを使うようにする．

### 動的配列
通常，配列はプログラム作成時に長さが決まっている(固定長配列)．
しかし，プログラムによっては配列の長さが予め決まっていない場合もある．
そのような場合には，```std::vector``` のような動的配列を用いる．

```cpp
class A
{
    ...
};

// int 型の動的配列
std::vactor<int> int_vector;
// クラス A の動的配列
std::vactor<A> A_vector;
```

動的配列を宣言しただけでは中身がからの配列となる．
初期値を与える場合には，通常の配列と同じように ```{}``` を使えば良い．
また，動的配列の現在の長さを取得する ```size()``` メンバ関数が用意されている．

```cpp
std::size_t size() const;
```

要素へのアクセスには添字演算子を使う．
一方，要素の追加や削除は次のようなメンバ関数を使う．

```cpp
void push_back(const T& value); // T はテンプレート引数で渡した型と同じ
void pop_bach();
```


## new と delete の使用
関数の仮引数やローカル変数は，そのスコープから出ると自動的に破棄されるが，
実際にはいつ，いくつ必要になるかわからないオブジェクトも存在する．
そのようなオブジェクトは動的確保する必要がある．  
動的確保では，スコープの影響を受けないフリーストア領域からオブジェクト確保に必要な領域を確保する．
動的確保された領域は，スコープを抜けても自動的に破棄されないため，プログラマが不要になるたびに破棄する必要がある．
また，動的確保ではメモリの確保に失敗することもある．
その場合には，```new``` 演算子が ```std::bad_alloc``` 例外を送出する．  
C++ では ```new``` 演算子と ```delete``` 演算子を使って動的確保と破棄を行う．

```cpp
type* variable = new type;
delete variable;
```

```new``` 演算子は，```type``` で指定した型のオブジェクトを1つ動的確保して，オブジェクトのアドレスを返す．
この時，通常はデフォルトコンストラクタが呼ばれる．
```delete``` 演算子は，デストラクタを呼び出し，```new``` 演算子で確保したオブジェクトを破棄する．
```delete``` 演算子でオブジェクトを破棄しないと，メモリリークの原因になるので，
必ず不要になったオブジェクトは破棄する．

## new と delete の詳細
### 割り当てたオブジェクトに初期値を与える
次のように ```new``` 演算子に対してコンストラクタの引数を渡すことができる．

```cpp
type* variable = new type(parameters...);
type* variable = new type{parameters...};
```

### 配列の動的確保
配列の動的確保も次のように行える．

```cpp
// 動的確保
type* variable = new type [array-length];
type* variable = new type [array-length] {initial-values...};

// 破棄
delete [] variable;
```

単一のオブジェクトの動的確保でも，配列の動的確保でも，全く同じポインタが返される．
しかしながら，配列を破棄する場合には必ず ```[]``` が必要になるので注意する．  
動的確保の2つ目の書式では，カンマ区切りで初期値を与える．
クラスの配列を作成したい場合には，関数形式の明示的な変換を使ってコンストラクタを呼び出せば良い．
もし，渡した初期値が指定した長さより短い場合には，デフォルトコンストラクタを使って初期化され，
指定よりも長い要素を与えた場合には，```std::bad_array_new_length``` エラーを送出する．
配列の動的確保では，実行時にならないと初期化リストの過不足が判定できないので，
デフォルトコンストラクタがない場合にはエラーとなる．


## {} による初期化と std::initializer_list
### {} による初期化
