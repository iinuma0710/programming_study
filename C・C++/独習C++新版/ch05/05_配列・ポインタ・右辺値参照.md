# 配列・ポインタ・右辺値参照

## 配列とポインタ
### ポインタへの暗黙変換
配列は先頭要素へのポインタとして暗黙変換される．
文字列リテラルも文字の配列なので同様に扱われるが，変更不可能な配列なので ```const``` 修飾されたポインタとなる．

```cpp
int array[] = {0, 1, 2, 3};

// 先頭要素のポインタ
&array[0]

// 配列からポインタへの暗黙変換 => 先頭要素のポインタと同じになる
int* ptr = array;
```

### 次のアドレス
配列をポインタに変換した場合，通常の配列と同様に添字演算子を用いて先頭以外の要素にアクセスできる．

```cpp
int array[] = {0, 1, 2, 3};
int* ptr = array;

// 先頭以外の要素にもアクセスできる
ptr[0]
ptr[1]
ptr[2]
ptr[3]
```

添字演算子を用いる以外にも，ポインタの加算や減算でもアクセス可能．

```cpp
int array[] = {0, 1, 2, 3};
int* ptr = array;

// 2番目の要素
ptr += 2
// 3番目の要素
ptr++
// 1番目の要素
ptr -= 2
// 0番目の要素
--ptr
```

### 配列と引数
引数として配列を渡す場合にも配列のコピーは作成できない．
関数の引数に配列を宣言した場合には，ポインタとして宣言されたものとして扱われる．
そのため，配列の長さが想定と異なる場合にもそのまま渡せてしまうので要注意．

```cpp
// 次の2つは同じ意味
void function(int array[5]);
void function(int* array);
```

### 配列の型と別名
配列はポインタに暗黙的に変換されるが，配列自体は配列の型を持っている．

```cpp
// 配列の型
type-name[array-length];

// 配列へのポインタ型
type-name(*)[array-length];

// 配列へのポインタ宣言
type-name(*pointer-nema)[array-length] = &array-name;

// 配列への参照型
type-name(&)[array-length];

// 配列への参照の宣言
type-name(&reference-name)[array-length] = array-name;
```

配列へのポインタや参照は型に配列の長さの情報を持っているので，範囲 for 文で走査することもできる．
また，```using``` 宣言で配列へのポインタや参照に別名を付けることができる．


## オブジェクトの配列
### オブジェクト配列と初期化
組み込み型と同様，クラスの配列を作ることもできる．
組み込み型の配列は，配列の長さと同じだけ初期値を与えることで配列の初期化を行う．
一方，クラスの配列を作る場合，明示的な型変換と呼ばれるコンストラクタの呼び出しを行い，
インスタンスの作成を行うことができる．

```cpp
type-name(arguments...)
type-name{arguments...}
```

この明示的な型変換で作成したコンストラクタを配列に詰め込むことで，配列の初期化できる．
初期化時に呼び出したコンストラクタの数より配列の方が長い場合，足りない分はデフォルトコンストラクタが呼び出される．

クラスを配列にする場合，不必要に大きな配列を作成するのは避ける．
これは，デストラクタの呼び出しが多くなり，処理速度が低下するのを防ぐためである．
また，配列は意図せず危険な操作ができてしまうことが多いため，できるだけコンテナクラスを使うようにする．

### 動的配列
通常，配列はプログラム作成時に長さが決まっている(固定長配列)．
しかし，プログラムによっては配列の長さが予め決まっていない場合もある．
そのような場合には，```std::vector``` のような動的配列を用いる．

```cpp
class A
{
    ...
};

// int 型の動的配列
std::vactor<int> int_vector;
// クラス A の動的配列
std::vactor<A> A_vector;
```

動的配列を宣言しただけでは中身がからの配列となる．
初期値を与える場合には，通常の配列と同じように ```{}``` を使えば良い．
また，動的配列の現在の長さを取得する ```size()``` メンバ関数が用意されている．

```cpp
std::size_t size() const;
```

要素へのアクセスには添字演算子を使う．
一方，要素の追加や削除は次のようなメンバ関数を使う．

```cpp
void push_back(const T& value); // T はテンプレート引数で渡した型と同じ
void pop_back();
```


## new と delete の詳細
関数の仮引数やローカル変数は，そのスコープから出ると自動的に破棄されるが，
実際にはいつ，いくつ必要になるかわからないオブジェクトも存在する．
そのようなオブジェクトは動的確保する必要がある．  
動的確保では，スコープの影響を受けないフリーストア領域からオブジェクト確保に必要な領域を確保する．
動的確保された領域は，スコープを抜けても自動的に破棄されないため，プログラマが不要になるたびに破棄する必要がある．
また，動的確保ではメモリの確保に失敗することもある．
その場合には，```new``` 演算子が ```std::bad_alloc``` 例外を送出する．  
C++ では ```new``` 演算子と ```delete``` 演算子を使って動的確保と破棄を行う．

```cpp
type* variable = new type;
delete variable;
```

```new``` 演算子は，```type``` で指定した型のオブジェクトを1つ動的確保して，オブジェクトのアドレスを返す．
この時，通常はデフォルトコンストラクタが呼ばれる．
```delete``` 演算子は，デストラクタを呼び出し，```new``` 演算子で確保したオブジェクトを破棄する．
```delete``` 演算子でオブジェクトを破棄しないと，メモリリークの原因になるので，
必ず不要になったオブジェクトは破棄する．

## new と delete の詳細
### 割り当てたオブジェクトに初期値を与える
次のように ```new``` 演算子に対してコンストラクタの引数を渡すことができる．

```cpp
type* variable = new type(parameters...);
type* variable = new type{parameters...};
```

### 配列の動的確保
配列の動的確保も次のように行える．

```cpp
// 動的確保
type* variable = new type [array-length];
type* variable = new type [array-length] {initial-values...};

// 破棄
delete [] variable;
```

単一のオブジェクトの動的確保でも，配列の動的確保でも，全く同じポインタが返される．
しかしながら，配列を破棄する場合には必ず ```[]``` が必要になるので注意する．  
動的確保の2つ目の書式では，カンマ区切りで初期値を与える．
クラスの配列を作成したい場合には，関数形式の明示的な変換を使ってコンストラクタを呼び出せば良い．
もし，渡した初期値が指定した長さより短い場合には，デフォルトコンストラクタを使って初期化され，
指定よりも長い要素を与えた場合には，```std::bad_array_new_length``` エラーを送出する．
配列の動的確保では，実行時にならないと初期化リストの過不足が判定できないので，
デフォルトコンストラクタがない場合にはエラーとなる．


## {} による初期化と std::initializer_list
### {} による初期化
これまで説明してきた通り，変数の初期化構文には何通りかあって，それらは基本的に同じように使える．
しかし，厳密にはいずれの初期化方法も挙動が異なり，特にコンストラクタ呼び出しで問題が生じやすい．

```cpp
class A
{
    int m_v;
    std::string m_n;

public:
    A(int, std::string);
    A(float);
};

// 1. OK : メンバの初期化リストでも {} を使うことができる
A::A(int v, std::string n) : m_v(v), m_n{n} {}

// 2. OK : 委譲コンストラクタでも {} を使うことができる
A::A(float) : A{-1, "float"} {}

int main()
{
    // 3. OK : () を使う
    A ap(42, "0");
    // 4. OK : {} を使っても良い
    A ab{42, "0"};

    // 5. OK : 関数形式の明示的な型変換
    A bp = A(42, "0");
    // 6. OK : bp の初期化と同様
    A bb = A{42, "0"};

    // 7. エラー : A(int, std::string) の呼び出しにならない
    A cp = (42, "0");
    // 8. OK : bb の初期化と同様，コンストラクタが有れば呼び出される
    A cb = {42, "0"};

    // 9. 要注意 : A(float) の方が呼ばれる (カンマ演算子により 42 が無視される)
    A dp = (42, 0.0);
    // 10. エラー : double から std::string への変換はできない
    A db = {42, 0.0};

    double pi = 3.1415926536;
    // 11. OK : ただし，double から float に暗黙の型変換がなされる
    // 縮小変換 (narrowing conversion) となる可能性
    A ep(pi);
    // 12. エラー :  double から float に安全な型変換ができない 
    // {} では週苦笑変換が禁止されている
    A eb{pi};
}
```

ブレース ```{}``` を使うことで，意図しない暗黙の型変換やコンストラクタの呼び出しを防ぐことができるので，プログラムの記述にはブレースを優先して使うことを意識する．
また，コンパイル生成のデフォルトコンストラクタを呼び出す場合には，メンバ変数の初期値が不定値となってしまうため，特に ```const``` インスタンスを作成する場合には，ブレースを使って 0 で初期化するよう明示的に示す．

### std::initializer_list
個数は不明だが同じ型の値をいくつも受け取りたい場合，メモリの消費量を抑えたり，初期化リストを用いて初期化を行うためには，```std::initializer_list``` という特別な型を使う．
```std::initializer_list``` は使い所が難しいので，無闇に使うとバグの原因となる．

## 参照渡し
実引数としてオブジェクトを関数に渡すと，その関数のスコープ内でのみ有効なコピーが作成され，関数のスコープを抜ける際に自動的にデストラクタが呼ばれてコピーは破棄される．
これは少なからずパフォーマンスに影響を与える．

この問題を解決する最も一般的な方法は，関数がオブジェクトの参照を受け取るようにすることである．
参照はオブジェクトのコピーを作らないため，先に述べたような問題は生じない．
しかし，非 ```const``` な参照は元のオブジェクトを変更する可能性もあることに注意する．

オブジェクトのコピーが作られるような関数の呼び出し方を値渡し (call by value)，参照を渡す呼び出し方を (call by reference) と呼ぶ．

## 参照を返す関数
演算子のオーバロードなどでは非常に役立つ機能である．

### グローバル変数の参照を返す関数
返り値としてグローバル変数の参照を返すことができ，受け取る側も参照として受け取っている．
一方，ローカル変数の参照を返した場合，その参照は無効な変数への参照となってしまう．
これをダングリングリファレンス (dangling reference) と呼ぶ．

### メンバ変数の参照を返す関数
コピーできなかったり，コピー処理に時間のかかったりするようなメンバ変数を返す場合に，しばしば用いられる．
この時，呼び出し側にコピーするかしないかの選択肢を持たせ，メンバ変数を変更したり中を見たりする場合にはコピーを作成するというような使い方ができる．

### 参照を返した場合の型推論
```auto``` を使って参照として型推論したい場合には，次のように記述する．

```cpp
auto& reference-name = expression;
```

## 右辺値参照
値を代入できるような変数や引数 (厳密には仮引数) は左辺値 (left hand side value) と呼ばれ，数値リテラルなどは右辺値 (right hand side value) と呼ぶ．
右辺値には関数の戻り値や関数形式の明示的な型変換も含まれる．

### 通常の参照と右辺値参照
通常の参照は左辺値でのみ初期化が可能で，右辺値では初期化できない．
右辺値参照 (r-value reference) は右辺値への参照のみを格納できる機能である．

```cpp
// 右辺値参照
type&& variable = R-value;
```

右辺値参照型の変数は左辺値であり，他の右辺値参照型変数を参照することはできない．

```cpp
// エラー．通常の参照は右辺値で初期化できない．
int& a = 1;

int v;
// エラー．右辺値参照は左辺値で初期化できない．
int&& b = v;
// エラー．右辺値参照型変数は左辺値であり，右辺値参照を初期化できない
int&& c = b;

// OK．右辺値参照型変数は左辺値なので参照を初期化できる．
int& d = b;
// OK．参照は左辺値なので右辺値を代入できる．
a = 10
// OK．右辺値参照は左辺値なので右辺値を代入できる．
b = 10
```

### 右辺値のアドレス
右辺値参照には値を代入することもできる．
右辺値はメモリ上のどこかにある変数ではないため，右辺値のアドレスを取ろうとするとエラーとなる．
同じ右辺値を使った右辺値参照でも，次のように異なるアドレスを持つ．
すなわち，右辺値参照として参照するときにはそれぞれ別のオブジェクトが作られる．

```cpp
int&& i = 0;    // &i:0x16eee3614
int&& j = 0;    // &j:0x16eee3604
```

### 右辺値参照のオーバーロード
引数に右辺値参照を取る関数を定義することで，実引数に右辺値を渡すと右辺値参照のオーバーロードを呼び出すことができる．
まれに，この仕組みを用いることで効率の良いプログラムを書ける場合がある．

### ムーブココンストラクタ
右辺値参照を受け取るコンストラクタをムーブコンストラクタ (move constructor) と呼ぶ．

```cpp
class class-name
{
public:
    class-name(class-name&& variable-name);
}
```

### コピーとムーブ
コピーとは複製の意味で，元のインスタンスとメンバ関数が同じになるように初期化を行う．
ただし，メンバ変数が動的確保したポインタを持っていた場合には，多重解放しないように新たにメモリ領域を動的に確保して変数をコピーするのが一般的である．
しかし，メモリの動的確保はパフォマンスに重大な影響を及ぼす．

一方，ムーブは所有権の移動を行う (ownership transfer)．
動的確保されたメモリは，インスタンスとは別に確保されたメモリ領域に置かれており，
インスタンスがそのメモリ領域を「所有」していると考えられる．
この所有権を譲渡するのがムーブである．
そのため，ムーブの方がコピーより処理が早く，メモリの消費も抑えられる．

所有権の移動を含む一連の動作はムーブセマンティクス (move semantics) とも呼ばれる．
ムーブセマンティクスはインスタンスを値で受け取る関数の呼び出しでよく見られ，
引数として渡したインスタンスを，関数から戻ってきた後では使わない場合に使用する．
一方，関数から戻ってきた後も，渡したインスタンスを使う場合には，インスタンスをコピーすれば良い．


## 関数ポインタと関数リファレンス
### 関数へのポインタ
関数も変数と同様アドレスを持ち，それを格納するポインタ型(関数ポインタ型)が存在する．
関数ポインタから関数を呼び出す場合には，間接参照演算子 ```*``` を使う必要はない．

```cpp
return-type (*variable-name)(parameters・・・) = &function-name;
```

### 関数リファレンス
関数へのポインタ型があるのと同様，関数にも参照型があり，これを関数リファレンスと呼ぶ．
関数リファレンスの定義や呼び出しは関数ポインタとほぼ同じ．

```cpp
return-type (&variable-name)(parameters・・・) = function-name;
```

### 高階関数 (higher order function)
引数として関数ポインタや関数リファレンスを持っていたり，戻り値として返したりするような関数を高階関数と呼ぶ．
高階関数を使って，関数の動作をカスタマイズすることができる．
ただし，関数ポインタや関数リファレンスは括弧が多く扱いづらいため，別名を用意して使うのが良い．

```cpp
// 関数型の別名
using predicate = bool(int);
// 関数ポインタ
predicate* fptr = &is_odd;
// 関数リファレンス
predicate& fptr = is_odd;
// 関数ポインタ型の別名
using predicate_ptr = bool (*)(int);
// 関数ポインタ
predicate_ptr ptr = &is_less_than_5;
// 関数リファレンス型の別名
using predicate_ref = bool (&)(int);
// 関数リファレンス
predicate_ref ref = is_less_than_5;
```

## ```this``` のキャプチャ
### メンバ変数のキャプチャ
メンバ関数の中でラムダ式を使うと，メンバ変数をキャプチャできない．
そのため，次のようなコードはエラーとなる．

```cpp
class C
{
    int a;

public:
    void show_a()
    {
        [a]() { // メンバ変数を直接キャプチャできないのでエラーとなる
            std::cout << "C::a = " << a << std::endl;
        }();
    }
}
```

### this ポインタのキャプチャ
メンバ関数内で使える ```this``` ポインタをコピーキャプチャすることは可能で，
これを用いてラムダ式内でメンバにアクセスできるようになる．

```cpp
class C
{
    int a;

public:
    void show_a()
    {
        [this]() { // this をキャプチャ，this->a としなくても良い
            std::cout << "C::a = " << a << std::endl;
        }();
    }
}
```

```this``` を mutable 指定していないラムダ式でコピーしても，指定先は変更可能なままである．

```cpp
class C
{
    int a;

public:
    void set_a(int value)
    {
        [this, value]() { // mutable 指定してない
            a = value; // this -> a = value と同じ
        }();
    }
}
```

メンバ関数が const 指定されている場合には，```this``` も const となり指定先は変更できない．

```cpp
class C
{
    int a;

public:
    void set_a(int value) const
    {
        [this, value]() mutable { // mutable 指定していても
            a = value; // this の中身は変更できないのでエラーとなる
        }();
    }
}
```

### インスタンス全体のコピー
ラムダ式内部での処理にはコピーを使いたいという場合には， ```this``` によるキャプチャでは不十分である．
そこで，キャプチャリストに ```*this``` を指定することで，インスタンス自体を丸ごとコピーでき，```mutable``` 指定がなければコピーされたインスタンスは変更不可となる．

## 関数ポインタに変換可能なラムダ式
ラムダ式のなかでローカル変数を使えるようにする機能がキャプチャであるが，
他の関数のローカル変数を参照できない通常の関数では同じことはできない．
もしキャプチャを使わないのであれば，ラムダ式を普通の関数に書き換えることができる．

```cpp
// ラムダ式を関数ポインタに変換
auto lambda = [](int a) { return a; };
int (*fptr)(int) = lambda;

// 直接，関数ポインタに変換することも可能
int (*fptr)(int) = [](int a) { return a; };
```